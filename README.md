# demo-design-patterns
个人实现设计模式，使用java语言



# 一、面向对象的设计原则

1. ## **单一职责原则**

*一个对象应该只包含单一的职责，并且该职责被完美的封装在一个类中。*

 

每一个职责都是变化的一个轴线，如果一个类有一个以上的职责，这些职责就耦合在了一起。这会导致脆弱的设计。当一个职责发生变化时，可能会影响其它的职责。另外，多个职责耦合在一起，会影响复用性。单一职责原则不只是面向对象编程思想所特有的，只要是模块化的程序设计，都需要遵循这一重要原则。

 

## *2.* **里氏替换原则**

*所有引用基类（父类）的地方必须能透明地使用其子类的对象。*

 

子类可以实现父类的抽象方法，子类也中可以增加自己特有的方法，但不能覆盖父类的非抽象方法。当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。Java多态基于该原则设计。

 

## *3.* **依赖倒置原则**

*高层模块不应该从低层模块导入任何东西，两者都应该依赖于抽象。抽象不应该依赖于细节，细节应当依赖于抽象*。 

 

采用依赖倒置原则尤其给多人合作开发带来了极大的便利，参与协作开发的人越多、项目越庞大，采用依赖导致原则的意义就越重大。依赖倒置原则就是要面向接口编程，理解了面向接口编程，也就理解了依赖倒置。Java多态基于该原则设计。

 

 

## *4.* **接口隔离原则**

*客户端不应该依赖哪些它不需要的接口。*

 

我们在代码编写过程中，运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。设计接口的时候，只有多花些时间去思考和筹划，就能准确地实践这一原则。Java多接口继承依赖该原则。

 

## *5.* **迪米特法则**

*每一个软件单位对其他单位尽可能少的了解，而且局限于哪些与本单位密切相关的的软件。* 

 

迪米特法则的初衷是降低类之间的耦合，由于每个类都减少了不必要的依赖，因此的确可以降低耦合关系。但是凡事都有度，虽然可以避免与非直接的类通信，但是要通信，必然会通过一个“中介”来发生联系。故过分的使用迪米特原则，会产生大量这样的中介和传递类，导致系统复杂度变大。所以在采用迪米特法则时要反复权衡，既做到结构清晰，又要高内聚低耦合。

 

## *6.* **开闭原则**

*软件实体应对扩展开放，而对修改关闭*



开闭原则具有理想主义的色彩，说的很抽象，它是面向对象设计的终极目标。其他几条原则，则可以看做是开闭原则的实现。我们要用抽象构建框架，用实现扩展细节。

 

## *7.* **组合/聚合复用原则**

*优先使用对象的组合，而不是使用继承来达到复用的目的*

 

组合/聚合复用原则可以使系统更加灵活，类与类之间的耦合度降低，一个类的变化对其他类造成的影响相对较少，因此一般首选使用组合/聚合来实现复用；其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。

 

 

综上所述，设计模式是一种标准化的解决方案，可以帮助我们解决一些特定的设计问题，提高软件的质量和可维护性。面向对象设计思想是一种基于对象的软件设计方法，它将现实世界中的问题抽象成为一个个对象，并将对象之间的交互作为解决问题的基本方式，包括封装、继承、多态、抽象和接口等概念。通过学习和运用设计模式和面向对象设计思想，可以提高软件的设计水平，提高代码的可读性、可维护性和可扩展性，从而更好地满足用户的需求。



# 二、UML

## 1.概述

**统一建模语言**（英语：*Unified Modeling Language*，缩写**UML**）是非专利的第三代建模和规约语言。

UML是一种开放的方法，用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统

的制品的开放方法。UML展现了一系列最佳工程实践，这些最佳实践在对大规模，复杂系统进行建模方

面，特别是在软件架构层次已经被验证有效。

## 2.UML图

> 类图是一切面向对象方法的核心建模工具。该图描述了系统中对象的类型以及它们之间存在的各种静态
>
> 关系。

例如：![image-20230523173825816](B:\github\demo-design-patterns\images\image-20230523173825816.png)

对应的代码：

```java
/**
 * @author SuanLa
 * @project java-design-patterns
 * @Date 2023/5/23 17:21
 */
public class Demo {
    private String variable;

    public void method(String var){}
}
```

## 3.类之间的关系

### 3.1关联关系

> 关联（Association）关系是一种结构化的关系，用于表示一个类对象与另一个类对象的之间的关系，在
>
> 代码中被关联的对象以成员变量的方式体现。

![image-20230523172826313](B:\github\demo-design-patterns\images\image-20230523172826313.png)

#### 3.1.1双向关联

> 不带箭头就是双向关联，如下图所示

![image-20230523174945519](B:\github\demo-design-patterns\images\image-20230523174945519.png)

#### 3.1.2单向关联

> 下面是一个单向关联的UML表示方式

![image-20230523175114597](B:\github\demo-design-patterns\images\image-20230523175114597.png)

#### 3.3.3自关联

> 类的属性对象包含自己的情况，如下图所示

![image-20230523175248222](B:\github\demo-design-patterns\images\image-20230523175248222.png)

#### 3.3.4多重性关联

多重性关联关系又称为重数性（Multiplicity）关联关系，表示关联对象之间存在数量关系。

- 数量关系符表示如下

- 1或1..1：表示另一个类的一个对象只与该类的一个对象有关系

- 0..*：表示另一个类的一个对象与该类的零个或多个对象有关系

- 1..*：表示另一个类的一个对象与该类的一个或多个对象有关系

- 0..1：表示另一个类的一个对象没有或只与该类的一个对象有关系

- m..n：表示另一个类的一个对象与该类最少m最多n个对象有关系（m ≤ n）

![image-20230523175750256](B:\github\demo-design-patterns\images\image-20230523175750256.png)

### 3.2聚合关系

> 聚合（Aggregation）关系表示整体与部分的关系，在聚合中成员是整体对象的一部分，成员对象可以
>
> 脱了整体对象而独立存在。
>
> ![image-20230523180030267](B:\github\demo-design-patterns\images\image-20230523180030267.png)

### 3.3组合关系

> 组合（Composition）关系也表示整体与部分的关系，在组合中整体对象可以控制成员对象的生命周
>
> 期，一旦整体对象消亡成员对象将消失。

![image-20230523180150867](B:\github\demo-design-patterns\images\image-20230523180150867.png)

### 3.4依赖关系

> 依赖（Dependency）关系是一种使用关系，在大多数情况下依赖关系体现在某个类方法参数上使用另
>
> 一个类的对象作为方法参数。

![image-20230523173414525](B:\github\demo-design-patterns\images\image-20230523173414525.png)

### 3.5泛化关系

> 泛化（Generalization）关系也就是继承关系。

![image-20230523174215619](B:\github\demo-design-patterns\images\image-20230523174215619.png)

### 3.6接口与实现关系

> 接口（Interface）之间也可以有与类之间关系类似的继承关系和依赖关系，接口与类之间同时还存在一
>
> 种实现（Realization）关系，在这种关系中类实现了接口中所有的操作。

![image-20230523174518485](B:\github\demo-design-patterns\images\image-20230523174518485.png)

# 三、工厂模式

> 简单工厂模式（**Simple Factory Pattern**）又叫做静态工厂方法模式（**Static Factory Method**
>
> **Pattern**），并不属于 GoF 的23种设计模式之一，是学习其他工厂模式的的基础。

其定义如下：

*Wikipedia says：Factory is an object for creating other objects – formally a factory is a function*

*or method that returns objects of a varying prototype or class.*

*工厂是一个用于创建其他对象的对象——从形式上讲，工厂是一个函数或方法，它返回不同原型*

*或类型的对象。*

*Providing a static method encapsulated in a class called the factory, to hide the*

*implementation logic and make client code focus on usage rather than initializing new*

*objects.*

*提供封装在名为工厂的类中的静态方法，以隐藏实现逻辑并使客户端代码专注于使用而不是初始*

*化新对象。*

![image-20230523181245380](B:\github\demo-design-patterns\images\image-20230523181245380.png)

在简单工厂模式结构图中包含如下几个角色：

- **Factory（工厂角色）**：工厂角色即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实

例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象；在工厂类中提供了静态的工厂

方法 factoryMethod() ，它的返回类型为抽象产品类型Product。

- **Product（抽象产品角色）**：它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方

法，它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建

的具体产品对象都是其子类对象。

- **ConcreteProduct （具体产品角色）**：它是简单工厂模式的创建目标，所有被创建的对象都充当

这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法。
